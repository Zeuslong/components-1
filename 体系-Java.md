# Java 基础

## Object

### == & equals()

`==` 测试的两个引用是否指向了同一个对象。

`equals()` 如果被重写，则按照重写规则匹配；如果 `equals()` 没有重写，那么默认为 Object 当中的 `equals()` ，其中的实现是使用 `==`。

基本数据类型：byte、short、char、int、float、long、double、boolean 中 `==` 比较的是他们的值是否相等。

引用数据类型使用 `== `比较的时候比较的是他们的堆内存地址。

String、Integer、Date 在这些类当中 `equals()` 有其自身的实现（一般都是用来比较对象的成员变量值是否相同），而不再是比较类在堆内存中的存放地址了。 

### hashCode()

在 Object 类中，`hashCode()`方法是本地方法，具体计算 hash 的值根据 JVM 的实现有不同，也可以通过 `	--hashCode = 1` 来指定使用特定的 hash 计算方式。

在没有重写的 `equals()` 当中，采用 `==` 来比较对象，所以如果两个对象相同，那么它们的 `hashCode()`值一定要相同；又因为 hash 计算本身可能会产生冲突，所以如果两个对象的 `hashCode()` 相同，它们并不一定相同。

### wait()

`wait()` 方法能够让持有锁的一个线程让出锁，然后进入锁对象的等待池，如果再次被唤醒，就进入锁对象的锁池。

当获取锁失败，或者自己放弃锁后，线程会被加入到一个 Wait set 当中去，等待被唤醒，也就是等待别的线程释放锁的时候，会唤醒这 wait set 当中的某一个或全部线程。（notify / notifyAll）

### clone()

Object.clone 方法会返回一个不同地址的新对象，但是其中的引用还是原来对象当中的引用。

属于浅克隆。

补充：

- 浅克隆：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。也就是说，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。
- 深克隆：被复制对象的所有变量都含有与原来的对象相同的值，那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。也就是说，深复制把要复制的对象所引用的对象都复制了一遍。

## String

### 实现

String 底层采用的是 `byte[]` 数组作为基础数据结构，`byte[]` 数组通过 `final` 关键字修饰，所以是不可变的，可以在程序间共享。

由 coder 保存编码的方式，同时会缓存它的 hash 值。

### charAt()

由于采用了 `byte[]` 作为数据结构，所以在 `charAt()` 这种方法里面，都是先把 index 翻倍，然后在取相邻的两个 byte，一个 char 占两个 byte 的条件下，再把这个两个 byte 组合成一个 char 返回。

### equals() 

1. 使用 == 比较是否指向同一个对象；
2. 如果不是，判断传入的对象是不是 String 类型；
3. 如果是，则比较两者的编码方式是不是一样；
4. 如果同种编码方式，再调用对应的编码方式，挨个比较里面的值；

### intern()

`intern()` 是一个 native 方法。

它的作用是，如果常量池当中有一个包含了等同于此 String 对象的常量，那么就返回这个常量的引用，否则就在常量池当中创建这对象然后再返回这个对象的常量。

### 内存分配问题

所有通过 new 关键字创建的对象都在 **堆** 上面，而所有用 `""` 引用的对象都在常量池当中。

```
String index = new String("index");
/**
创建了两个对象：
"index" 在字符串常量池当中，如果字符常量里面没有 index 这个字面量，那么就会重新分配在字符常量池当中分配，如果有就算了
在堆当中创建了一个 String 的对象，然后其中的值引用了字符串常量池当中的字面量
**/
```

### StringBuilder 与 StringBuffer

- String 不可变；

- StringBuffer 内部使用 synchronized 是线程安全的，但是性能较低；

- StringBuilder 不是线程安全的，但是性能高；

## 集合

### HashMap

#### 什么是 HashMap

HashMap 是一个 **key-value** 映射形式的数据结构，它利用的 **数组** + **链表** + **树** 三种数据结构实现的。

#### get() 方法

get() 方法是通过用元素的 `hash 码`与 `table 的长度 - 1` 做**除余运算**然后找到桶位置，然后再加入到桶头节点或者桶上的链表/树当中去的。

1. 检查 table 的合法性，如果不合法返回 `null`；
2. 计算桶位置；
3. 如果当前桶位置的 key 和传入的参数 key 一样，那么就直接返回头节点；
4. 否则检查这个节点是不是 `TreeNode`，如果为 `TreeNode` 那么就返回 `getTreeNode()` 结果；
5. 否则遍历普通 `Node` ，如果找到一个 key 值与参数 key 相同的就返回，如果直到最后没有找到就返回 null；

#### put() 方法

1. 检查 table 是否为空，或者 table 的长度是否为 0 ，如果是的话，就执行 resize 方法进行 table 初始化；
2. 计算 hash 值找到桶位置；
3. 看当前桶位置是否为 **空**，如果为空就依据传进来的 key-value 创建 node 节点；
4. 如果不为空，就执行解决 hash 冲突的策略；
5. 用 `==` 与 `equals` 检查当前桶位置的 key 与传入的 key 是否相同，如果相同，那么就替换；
6. 检查该节点是否为 TreeNode 节点，如果是就执行 `putTreeVal()` 方法；
7. 如果是普通 Node 节点，依次查询这个链表上面的所有元素，查找是否有 key 值与传入的参数 key 相同的节点；
8. 如果在节点少找到元素，就替换；
9. 如果没有，就在末尾根据传入的参数新建节点；
10. 如果是替换操作，在替换完成的时候就返回 oldValue，如果是新增操作 `modCount + 1`，并且检查负载因子大小是否需要执行 `resize()`；

#### resize() 方法

`resize()` 方法最核心的地方在于要把原来链表上的元素重新散列到新的桶位置当中去，这个过程不是通过重新计算 hash 值的余数来完成的，而是通过 `(hash & oldCap) == 0` 来判断。`oldCap = 16`，加入桶的位置为 `hash % (oldCap - 1)`

1. 查看 table 是否有初始化过，然后重新设定容量与阈值大小；
2. 如果有初始化过；
  3. 检查是否大于或者等于最大的限定 `1<<30`，如果如果是，则把阈值设定为最大常数；
  4. 如果不是，那下一次扩容如果没有益处，并且旧的容量大与等于默认的初始容量，如果是右移一个单位(乘以2)；
5. 如果没有初始化过检查是否设定了负载因子；
6. 如果都没有初始化table并且没有设定阈值，那么重新计算阈值与设定容量大小；
7. 最后检查一次阈值，如果阈值还是为0，再次计算一次阈值；
8. 设定完容量大小与阈值后，开始重新设定 table；
9. 设定阈值与初始化 table 数组；
10. 遍历旧的 table 数组，取出元素并设定旧的 table 数组的元素位置为空；
11. 如果是一个 Node 节点，重新通过 hash 值计算位置；
12. 如果是 TreeNode 调用 `split()`；
13. 如果是 Node 链表，遍历 table 中的头元素，重新散列冲突的元素；
14. 用元素的 hash 值与原来的容量做比较，如果为 0 则表示以前的哈希值的容量位置对应的 1 的地方也为 0，那么用新的来散列的话还是原来的位置，就记录到新的链表 loHead 当中；
15. 如果做 & 运算的结果为 1 ，那么就表示新的容量 length - 1 来计算桶位置的时候，它的高位会影响它的新位置，那么就记录到 hiHead 当中；
16. 把 loHead 链表赋值给原来桶的位置，把 hiHead 赋值给新的桶位置(原来的桶位置+原来的容量)；

*散列冲突寻找新的桶位置的原理如下*：

```
// 原理

/**

假设原本的容量为 16
对应的二进制为 0001 0000

新的容量为 32
对应的二进制为 0010 0000

对象的 hash = 0001 0101

那么在原有的桶位置为

0000 1111
0001 0101
---------
0000 0101 = 5

也就只有后4位起了作用

在新的桶位置的位置为

0001 1111
0001 0101
---------
0001 0101 = 21 = 5 + 16

便是后5位起了作用

而原本的桶容量的二进制刚好为五位，就可以验证 hash 码的第五位是否为 1 ，如果为 1 ，就需要改变对象在新桶当中的位置

**/
```

#### Hash 计算桶位置

hash 一般用来计算桶的位置，通过 `hash % table.length - 1` 的方式得到桶位置

```
    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 ： (h = key.hashCode()) ^ (h >>> 16);
    }
```

如果 key == null，那么 hash 默认为 0

如果不是，通过虚拟机为该 key 计算得到的一个 hashCode 值的前 16 位高位与后 16 位高位做异或运算然后得到一个 hash 值，这样做是为了混合原始 hash 值的高位和低位增加了低位的随机性。

#### HashMap 如何比较 Key

先求出 key 的`hashCode()`，比较其值是否相等，若相等再比较`equals()`，若 `equals()`相等则认为他们是相等的；若`equals()`不相等则认为他们不相等。

#### 当 Key 为自定义类时

当 Key 为自定义类时，需要重写 Key 的 `equals()` 方法与 `hashCode()` 方法。

HashMap 中的比较 key 是这样的：先求出 key 的`hashCode()`，比较其值是否相等，若相等再比较`equals()`，若 `equals()`相等则认为他们是相等的；若`equals()`不相等则认为他们不相等。
 如果只重写 `hashcode() ` 不重写 `equals()` 方法，当比较 `equals()` 时只是看他们是否为同一对象（即进行内存地址的比较），所以必定要两个方法一起重写。

#### 如何让 HashMap 散列更均匀

当容量为 2 的幂次方的时候，由于做 hash 找 index 的过程是 length-1 所以，偶数 - 1 变成奇数，基数当中的二进制最后一位是 1 ，这样就可以充分利用到 hashcode 当中的最后一位，从而散列的均匀一点。

对应在 HashMap 当中，则是计算 Key 的桶位置时，使用的是 Key 的 `hashCode()` 与 `table.length - 1` 来计算桶位置。

#### 为什么 HashMap 中 table 长度要为 2 的幂次方

默认的初始容量为 `1<< 4 (16)`，当容量一定是 2^n 的时候，那么末尾一定是 1，这个时候 `h & (length - 1) == h % length`，而按位运算会很快

#### HashMap 的负载因子是多少

在 Java Doc 注释里面有写，通常，HashMap 的 `load factory` 为 **0.75** 便可以在 **时间** 和 **空间** 上有一个较好的平衡。

太低的  `load factory` 会导致 HashMap 频繁的执行 `resize()` 方法来重新分配 table 空间；太高的  `load factory` 可以降低空间消耗，但是会增大查找的花费，因为较高的值如果初识数量大于负载因子所限制的最大条目数，那么就不会发生 `rehash` 操作。

#### fast-fail 策略

如果一个迭代器被创建了，一旦在迭代器中进行迭代时， HashMap 发生了结构变化，那么迭代器就会抛出异常 `ConcurrentModificationException`

#### HashMap 的死循环

HashMap 的死循环出现在并发环境下执行 `resize` 方法，当并发加入 put 的时候，引起扩容操作，然后多线程导致 HashMap 的 Entry 链表形成环形数据结构，查找时候会引起死循环/

具体的过程如下：

当有一个线程刚进入 get 方法的时候执行 `Entry next = e.next()` 方法后被挂起，然后新线程进入，并执行了扩容的操作，如果新的扩容后的链表的位置发生了反转，那么这个时候环形就形成了。

假如有两个线程 P1、P2，以及链表 `a->b->null`：

1. P1先执行，执行完`Entry<K，V> next = e.next;`代码后发生阻塞，或者其他情况不再执行下去，此时 `e=a，next=b`；

2. 而P2已经执行完整段代码，于是当前的新链表 `newTable[i] 为 b->a->null`；

3. P1又继续执行`Entry<K，V> next = e.next;`之后的代码，则执行完`e=next;`后，`newTable[i]`为`a<=>b`，则造成回路，`while(e!=null)`一直死循环；

#### HashMap 与 HashTable 区别

1. HashMap 不是线程安全的，HashTable 是线程安全的；

2. HashMap 允许 null 为键或值，Hashtable 不允许；

3. HashTable 直接使用对象的 hashCode 做运算，HashMap 会把 hashCode 的前后 16 位进行与运算；

4. 另一个区别是 HashMap 的迭代器 (Iterator) 是 fail-fast 迭代器，而 Hashtable 的 enumerator 迭代器不是 fail-fast 的。所以当有其它线程改变了 HashMap 的结构（增加或者移除元素），在迭代过程中将会抛出ConcurrentModificationException

5. HashMap 的数组初始化默认容量为 16，Hashtable 默认为 11；

#### HashMap 与 TreeMap 的区别

1. HashMap 不保证顺序；TreeMap 能根据键来排序，默认是升序排序，Iterator 遍历 TreeMap 得到的有序的结果；

#### 让 HashMap 同步

使用 Collctions 封装 HashMap 为 ConcurrentHashMap

```java
Map m = Collections.synchronizeMap(hashMap);
```

### ConcurrentHashMap

#### ConcurrentHashMap 数据结构

- 1.8 之前

  ConcurrentHashMap 当中维护一个 segment 数组，将元素分作若干部分，segment 继承了 ReentrantLock，在每一个 segment 当中又包含一个 HashEntry 数组。每一次并发都是第一次 hash 获取 segement 锁，再次 hash 找到元素。所以默认的 segment 数量为 16，也就只支持 16 个线程并发。

- 1.8 之后

  ConcurrentHashMap 当中维护了一个 Node 数组 + 链表/红黑树，Node 当中有 final 的 key 与 volatile 的 value 与 next。并发的方式改成了 synchronized 关键字控制。

在 ConcurrentHashMap 当中使用 volatile 关键来保证读取到工作内存当中的 table 都是最新的，所以 volatile 只会保证读取的时候数据是准确的。

在 ConcurrentHashMap 当中，如果要保证写入的时候操作是线程安全的话，那么还是需要 synchronized 来做线程同步操作。

#### ConcurrentHashMap 如何保证线程安全

ConcurrentHashMap 当中保证线程的安全性主要是通过 volatie、CAS、Synchronized 三个措施来保障线程安全性的。

其中 volatile 主要用来保证**读**的线程安全性。

在 ConcurrentHashMap 当中，用 volattile 来修饰 Node 数组，这样就保证了如果有一个线程修改了 Node 数组当中的数据，那么就会使读线程当中的 Node 数组无效，然后读线程就会重新在主内存当中去加载 Node 数组的数据到线程当中。

对于**写**操作的线程安全性的措施主要是依靠 CAS 与 Synchronized 关键在实现的。

写操作主要涉及到如下几个步骤：

1. 获取 value 的桶位置（也是利用 hash 与 Node 数组长度除余来获得的）；
2. 获取 Node 结点（通过 Unsafe 类的 Volatile 语义的方法来获取的）；
3. 插入 Node 结点（CAS）；
4. 插入 Node 到链表当中去（加锁 Synchronized）；

其中，如果是插入 Node 节点时，由于插入结点这个操作不会对其它的数据有影响，所以就可以用 CAS 来替代锁住整个 Node 结点数组这个过程，所以在并发的时候如果有必要加锁，那么数组的其它 Node 结点同样是可以访问的，也就提高了并发量。

对于插入 Node 结点到链表或者树当中去这个操作，就需要获取锁来进行操作。

在 ConcurrentHashMap 的注释当中有这样一句话：ConcurrentHahsMap 的查询操作只会保证获取到线程上的某一个时间的状态，而不会获取到最新的状态，这也就是说 ConcurrentHashMap 本身是没有采用读写锁，而在做更新操作的时候，根据更新的位置的不同来判断所采用的更新方式，通常情况下不会对 Node 数组加锁，那么也就不会对大部分的读操作有锁定的影响，会提升性能。

通过上面的这个两个过程就能保证 ConcurrentHashMap 在写的时候的线程安全性。

#### put() 方法

ConcurrentHashMap 的更新操作与 HashMap 也大致相同，但其中采用了 CAS 更新方法、synchronized 关键字来同步线程。

ConcurrentHashMap 执行更新操作分作两种情况，一是当前插入的地方是一个空节点的，二是当前插入的地方已经存在一个元素。

如果插入的地方是一个空节点，那么利用 CAS 原理，把元素插入。

如果插入的地方已经存在一个元素，那么就要先获取这个元素的锁，获取锁之前，要先检查是否有其它线程在扩容，那么有，则会完成扩容操作，然后获取这个结点的锁，从头开始遍历这个结点，遇到 hash 相同的就替换，否则末尾插入。

最后检查是否需要扩容或者转成树。

#### get() 方法

ConcurrentHashMap 的查找过程与 HashMap 大致相同。但是在获取的时候有两个关键的地方，一是被 volatile 关键字修饰的 table，二是 tabAt 方法。

ConcurrentHashMap 的底层 table 是被 volatile 修饰的，也就是说，每一次要去使用 table 的时候，如果有别的线程修改了 table，那么当前线程的 table 缓存就会失效，然后去内存的当中重新获取 table 元素，保证了 table 是某一个时刻上面最新的。

然后计算桶位置，在 table 上面获取节点，这个时候 tabAt 方法调用了 Unsafe 类当中的 getObjectVolatile 方法，这个方法是拥有 volatile 语意的，保持原子操作的情况下，去内存当中根据对象地址和内存地址的偏移量直接获取对象，也保证了该对象在某一时刻的最新性。

然后获取到链表的头结点后，按照访问链表的方式来遍历链表，并且不需要加锁。

#### 为什么 ConcurrentHashMap 的参数都不能为空

ConcurrentHashmap 和 Hashtable 都是支持并发的，这样会有一个问题，当你通过 `get(k)`获取对应的 value 时，如果获取到的是 null 时，你无法判断，它是 `put（k，v）` 的时候 value 为 `null`，还是这个 key 从来没有做过映射。
HashMap是非并发的，可以通过 `contains(key)` 来做这个判断。而支持并发的 Map 在调用 `m.contains(key)和 `m.get(key)` ，由于读取未上锁，m 可能已经不同了。

#### ConcurrentHashMap 的特殊点

1. ConcurrentHashMap 是一个类似于 HashTable 的线程安全的 HashMap，它遵循了 HashTable 的功能规范，含有 HashTable 当中每个方法的方法版本，但是与 HashTable 同步的细节不相同；
2. 在访问 ConcurrentHashMap 的哈希表的时候，所有的操作都是要求是线程安全的，但是检索操作通常是不需要的，并且使用方法的所有参数都不能为空，也不允许存在空的 key 与 value；
3. 它的状态查询方法例如：isEmpty()、size 都是反应某一个时刻的状态，其创建的迭代器也只是某一时刻所包含的键值对，并且只能被一个线程持有，而且不会有 ConcurrentModificationException；
4. ConcurrentHashMap 的 table 初始化发生在第一次插入的操作时候。

### ArrayList

1. ArrayList 本质上是一个可改变大小的数组。当元素加入时，其大小将会动态地增长。

2. 内部的元素可以直接通过 `get()` 与 `set()` 方法进行访问，随机访问很快。

3. 删除非头尾元素慢，新增元素慢。由于需要预留一部分空间用于后续元素的插入所以也相对比较浪费空间，较适用于无频繁增删的情况。

4. ArrayList 非线程安全。
5. 一直在末尾添加元素是，ArrayList 效率比 LinkedList 效率更高，ArrayList 虽然可能需要扩容，但是它的平均插入应该是 O(1)；LinkedList 在插入链表末尾的时候，不需要扩容，但是它的插入末尾需要移动指针到末尾，所以它的效率是 O(n)。

### LinkedList

1. LinkedList 是一个链表，在添加和删除元素时具有比 ArrayList 更好的性能。
2. 但在 `get()` 与 `set()` 方面弱于 ArrayList。
3. 适用于：没有大规模的随机读取，有大量的增加/删除操作。随机访问很慢，增删操作很快，不耗费多余资源。
4. 允许null元素。
5. 非线程安全。

### Vector

1. Vector 类似于 ArrayList，底层是数组，但其是同步的，开销就比 ArrayList 要大。
2. Vector 和 ArrayList 在更多元素添加进来时会请求更大的空间。Vector 每次请求其大小的双倍空间，而 ArrayList 每次对 size 增长 50%。

## 并发

### 线程

#### 什么是进程

进程是计算机当中已运行程序的实体，当操作系统调度进程的时候会给它独立的资源例如内存空间 CPU 资源等等。

#### 什么是线程

线程是进程当中的一个任务的描述，一个进程当中含有多个线程，线程可以利用进程所拥有的资源。

#### 线程与进程的区别

1. 进程是操作系统分配资源的最小单位，而线程是独立运行和独立调度的基本单位。
2. 进程享有独立的内存单元，而多个线程共享进程的内存空间。
3. 二者均可并发执行，但是进程的创建和销毁需要系统对进程分配或销毁所以线程在并发过程中的创建、切换、销毁成本更低。

#### 线程的生命周期

- 新建状态：当一个线程被关键字 `new` 创建出来的时候，就处于新建状态，JVM 为其分配内存空间与初始化其成员变量
- 就绪状态：当一个线程执行 `start()` 方法后，就处于就绪状态，或者当一个线程正在被调度运行的时候，也是处于就绪状态，等待获取系统资源被执行
- 运行状态：当一个线程得到了系统资源后，开始执行 `run()` 方法当中的代码后
- 阻塞状态：线程主动的让出 cpu 资源，等待某条件满足的状态就叫阻塞状态 1.执行 `sleep` 方法主动让出 cpu 资源 2.等待 IO 完成 3.执行 `wait` 后等待被唤醒 4.等待获取锁权限
- 死亡状态：当一个线程执行完 `run` 方法后，或者执行 `interrupt` 方法强制中断线程

#### start() 与 run()

`run()` 方法当中封装的是多线程需要处理的任务逻辑代码，如果单独执行`run()` 方法那么线程没有成功启动而只是在本线程当中执行。

`start()` 方法是启动新创建的线程，而且 `start()` 内部调用了 `run()` 方法。

#### Runnable 与 Callable

Runnable 接口不返回任何结果。

Callable 则需要返回结果。

#### Runnable 与 Thread

采用 Thread 的时候， 只能继承一个类， 如果这个类需要继承其它类则不考虑 Thread。

如果使用 Runnable 实现接口能够更好的独立出逻辑块， 因为一个 Runnable 通常被理解为一个任务。

#### interrupted() 与 isInterrupted() 

两者都是调用 `isInterrupted(boolean ClearInterrupted)` 方法，来判断当前运行的线程是否被中断了。

interrupted 传递的参数为 `true` 也就是会重置 `interrupted state` 状态变量，也就是说如果第二次调用，这个期间当前线程只被中断过一次的话，就会返回 `false`。

isInterruptedd 传递的参数为 `false` 不会重置 `interrupted state` 状态变量。

*!* `interrupted state` 用来标识当前线程是否被中断了。

#### notify() 与 notifyAll() 

我的理解中，在 Java 的并发当中所有的对象都存在一个 `锁队列` 和 `等待队列`，当执行对象的 `wait()` 方法的时候，就会把执行的线程加入到等待队列当中，等待队列当中的线程不参与锁的竞争，`notify()` 方法是用来唤醒等待队列当中某一个线程进入到锁队列当中去参与锁竞争，而 `notifyAll()` 方法则是唤醒等待队列当中的所有的线程到锁队列当中参与锁的竞争。

#### wait() 和 sleep() 

wait 的含义是在本对象的等待队列上等待被其它唤醒， 不仅仅要放弃当前所获得的锁权限， 而且在没有被唤醒的时候不参与锁的竞争。

sleep 的含义是休眠该线程， 也就是阻塞的意思， 不会放弃当前线程的锁权限， 也不会放弃争夺锁的权限。

#### ThreadLocal

ThreadLocal 是一种用空间换取线程安全的做法，线程可以把原本在内存共享区域的数据拷贝到自己的线程内存上面，如果线程修改了这个数据不会影响到主内存当中原本的数据，只会修改自己线程线程空间的那份数据。

ThreadLocal 是一个类，要使用到 ThreadLocal 的类需要内部持有这个类，ThreadLocal 内部有 get 和 set 方法来满足大部分需求，TheadLocal 利用 ThreadLocalMap 来存取对象，Map 当中 key 为 ThreadLocal 自己，value 为值。

#### Java 线程调度算法

采用抢占式算法。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。

Java 采用抢占式线程调度的方法，每个线程由操作系统来分配时间，线程的切换不由线程本身来决定，在这种调度方式下，线程的执行时间是系统可控的，不会导致由于一个线程使整个进程阻塞的问题。

但是 Java 当中可以通过 `Thread.yield()` 方法来主动让出执行时间。

Java 当中也可以设置优先度，在 Java 当中有 10 个级别的优先度分别来映射操作系统上的优先级，可能没有办法一一对应，所以并不是很可靠，所以最终还是要取决与操作系统。

### 锁

#### 独享锁与共享锁

独享锁是指该锁一次只能被一个线程所持有。

共享锁是指该锁可被多个线程所持有。

ReentrantLock、Synchronized 是独享锁

ReadWriteLock 其读锁是共享锁，其写锁是独享锁。

#### 公平锁与非公平锁

公平锁指的是有多个线程申请锁的时候，按照线程申请的先后顺序来获取锁。

非公平锁指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。

synchronized 是非公平锁。

ReentrantLock 可以通过构造方法指定是公平锁还是非公平锁。

##### 比较

事实上公平的锁机制往往没有非公平的效率高，因为公平的获取锁没有考虑到操作系统对线程的调度因素，这样造成 JVM 对于等待中的线程调度次序和操作系统对线程的调度之间的不匹配。此外，在锁的快速且重复的获取过程中，连续获取的概率是非常高的，而公平锁会压制这种情况，虽然公平性得以保障，但是响应比却下降了。

公平锁能够减少“饥饿”发生的概率，等待越久的请求越是能够得到优先满足。

#### 互斥锁

互斥锁独享锁具体的实现。

互斥锁在 Java 中的具体实现就是 ReentrantLock。

#### 读写锁

读写锁就是共享锁的具体实现。在写入的时候只允许一个线程执行读写，当没有写入操作时，可以允许多个读操作并发执行。

读写锁在 Java 中的具体实现就是 ReadWriteLock。

#### 乐观锁与悲观锁

乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。

悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。

悲观锁适合写操作非常多的场景。在Java中的使用，就是利用各种锁。

乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断的更新数据。乐观的认为，不加锁的并发操作是没有事情的。

乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。在Java中的使用，是无锁编程，常常采用的是 CAS 算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。

#### 重入锁

重入锁指的是一个线程能够对一个临界资源重复加锁。例如，是当一个线程获取到一个对象的锁并执行其中的方法时，它调用这个对象当中的另外的一个方法，可以不用再进入锁队列去抢占锁的控制权，可以直接调用另外的一个方法。

在 Java 当中，ReentrantLock、synchronized 是重入锁。

### CAS 算法

CAS 全称**比较与交换（Compare and Swap）**。

CAS 会先备份旧的数据，然后基于旧的数据进行修改数据，当数据修改完成后，比较备份的旧数据与当前内存当中的数据，如果相等，则证明共享数据没有被修改，替换成新值；如果不相等，说明共享数据已经被修改，放弃已经所做的操作，然后重新执行刚才的操作。

### AbstractQueuedSynchronized

AQS 提供阻塞和唤醒线程功能以及队列模型的简单框架，许多同步类实现都依赖于它，如常用的 ReentrantLock。

#### 基础结构

AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是单项列表来实现的，将暂时获取不到锁的线程加入到队列中。AQS是通过将每条请求共享资源的线程封装成一个队列当中的节点来实现锁的分配。

AQS 中还维护了一个名为 state 的字段，意为同步状态，是由Volatile修饰的，用于展示当前临界资源的获锁情况。子类可以通过修改State字段来实现多线程的独占模式或者共享模式。

### ReentrantLock

ReentrantLock 是一个重入锁，也可以通过构造方法来指定其是否是一个公平锁，但默认是一个非公平锁。

其内部是通过扩展 AQS(AbstractQueuedSynchronizer) 来实现的。

```java
Lock lock = new ReentranLock();
lock.lock();
try{
    //do something
}finally{
    lock.unlock();
}
```

#### 获取锁

获取锁的过程主要与两个东西相关：

1. AQS，阻塞的线程都放在这个队列当中；
2. state 状态码，表示进入线程的次数，每重入一次会 +1，每释放一次 -1；

ReentrantLock 的 lock 过程其实是调用了 AQS 的 acquire 方法。

在 AQS 的 acquire 方法当中，线程获取当前的锁，主要有两个过程：1.尝试获取锁过程。2.进入阻塞队列。

尝试获取锁的过程：

首先判断 AQS 的 state 是否等于 0，state 为 0 则表示锁没有人占有，接着，hasQueuedPredecessors 判断队列是否有排在前面的线程在等待锁，没有的话调用 compareAndSetState 使用 cas 的方式修改 state，最后线程获取锁成功，然后将线程记录为独占锁的线程。

若果前面有人占着锁，就会检查是否是当前线程，如果是当前线程就继续执行。

如果两个判断都没有执行通过，就加入等待队列。

加入队列的时候使用的是一个死循环，保证一定会插入到队列当中，在加入等待队列的时候，Node 对象的初始化，会自动的获取当前线程，并传入到 Node 当中持有。

如果没有获取到锁并且成功的加入到等待队列当中后，就会中断当前线程。

#### 释放锁

在 AQS 当中有一个 state 状态码，用来维护当前线程进入的次数，保证线程的重入时候要释放相同次数，也是其它线程获取锁的一个参考参数。

释放锁的时候，主要对比当前的线程与当前锁拥有者是否一致，然后在改变 AQS 当中的 state 状态码，表示有一个线程已经退出。

然后通过 AQS 获取队列当中的线程来临界资源的占用。

## NIO

### 阻塞/非阻塞与同步/异步

阻塞与非阻塞指的是等待数据的一种方式。阻塞指的是数据还没有就绪时，就等待数据，直到数据就绪后再继续执行；非阻塞在数据没有就绪时，会直接返回，继续执行当前方法。

同步与异步指的是查询数据是否就绪的方式。同步指的是主动轮询各个数据准备的状态；异步指的是数据就位后通知进程数据已经就位。

综上，阻塞与非阻塞，讨论的是进程想要获取结果的时候的一种状态(等或者不等)，而异步与同步讨论的是，消费者获取服务者任务执行状态的一种方式。

### 什么是 NIO

NIO 叫做 nonblocking IO，是一种同步非阻塞的 IO 方式。

在普通的 IO 当中，当应用程序需要进行 IO 的时候，它会去调用系统当中的方法，这个系统调用会导致应用程序的阻塞，然后等待操作系统将数据拷贝到内核当中，再从内核拷贝到用户进程当中，只有到数据全部准备好之后，应用程序才会被唤醒，再进行数据的处理。

而 Java 当中的 NIO，在执行系统调用后，系统会立即给应用程序返回，然后 Java NIO 应用程序就不需要再等待，但是它会每一隔一段时间再来获取系统当中 IO 的状态，如果数据没有准备好的话，就会返回一个 ERROR，当数据返回后应用程序不需要再等待，可以继续做其它的事情，然后不断的对系统进行轮询直到找到自己可以用的数据为止。

### Java NIO 模型

Java NIO 模型是基于反应器模式来设计的。

Channel 把自己注册到 Selector 上面去，然后告诉 Selector 这个 Channel 所关心的事情，然后应用程序就会接着做别的事情。

Selector 会反复的对数据进行轮询，当 Channel 所感兴趣的事情发生的时候，Selector 就会唤醒这个 Channel 然后执行操作。

### NIO 主要组件

#### Channel

Channel 叫做管道，向 Buffer 当中写入数据，或者读取数据

- FileChannel

文件的数据读写

- DatagramChannel

UDP 数据的读写

- SocketChannel

TCP 数据的读写

- ServerSocketChannel

允许我们监听TCP链接请求，每个请求会创建会一个SocketChannel

#### Buffer

缓存区，主要是暂时保存 Channel 写入的数据，也是让 Channel 读取数据的地方

利用Buffer读写数据，通常遵循四个步骤：

```java
    把数据写入buffer；
    调用flip；
    从Buffer中读取数据；
    调用buffer.clear()或者buffer.compact()
```

具体的实现：

- ByteBuffer
- MappedByteBuffer
- CharBuffer
- DoubleBuffer
- FloatBuffer
- IntBuffer
- LongBuffer
- ShortBuffer

#### Selector

注册对各种 I/O 事件的兴趣的地方，而且当那些事件发生时，Selector 就会告诉您所发生的事件。

### FileChannel

FileChannel 是 Java NIO 类库当中处理文件数据的一个抽象类，虽然是 NIO 类库当中的一员，但是 FileChannel 在读取与写入数据的时候，依旧是阻塞的，也就是说在 FileChannel 在读入数据的时候，还是要等到数据进入到操作系统内核内存，然后再从内核读入进程内存，然后才可以开始操作。

但是个人认为 FileChannel 的出现对于 Java IO 体系来讲并不是多余的。网上流传的 NIO 有很多种含义：1.Non-blocking IO。2.New IO。第一种含义意思是非阻塞的 IO，也就是当我们执行其中的某些方法的时候，当方法没有执行完毕的时候，原本是应该被阻塞的，但是在非阻塞的 IO 方式当中，就算没有执行完毕，也是可以直接返回的。第二种含义的意思是一种新的 IO 思维，NIO 所有的 IO 类后都有一个后缀叫做 Channel，Channel 译过来是通道的意思，这一种含义更贴近 FileChannel 的设计理念，FileChannel 是一个双向操作的 IO 流，传入对应的文件路径并且打开 FileChannel 之后既可以执行读操作也可以执行写操作，在这样的工作机制下，当我们需要对文件进行操作的时候，只需要打开对应文件的 FileChannel，再申请一个 Buffer 就可以直接操作，不用关心读取的时候的一些细节的控制。

# JVM

## 并发

### Sychronized

Synchronized 是 Java 内置的一个关键字，用来防止资源冲突，当任务要执行被 synchronized 关键字保护的代码片段的时候，它将检查片段的锁是否被别的线程持有，然后获取锁，执行代码，释放锁。

#### 原理

在 JVM 中所有的对象都自动含有单一的锁，也叫做监视器。当在某一个对象上面调用任意的 synchronized 方法的时候，这个对象会被锁定，这时候其它再来请求该对象其它的 synchronized 方法只有等到前一个方法调用完毕并释放了锁之后才能被调用。所以在同一个对象当中，所有的 synchronized 的方法共享同一个锁。

#### 实现机制

synchronized 方法的实现第一步在编译成字节码的时候就开始了，JVM 的字节码中被 synchronized 修饰的方法在的 Class 文件方法表当中 access_flag 字段当中的 synchronized 标记为 1 表示是一个同步的方法。

编译器会把 synchronized 块编译成 `monitorenter` 与 `monitorexit` 包裹的代码块，然后把方法翻译成普通的方法。

JVM 被要求保证当线程执行到 `monitorenter` 与 `monitorexit` 要成对使用，并且任何一个对象都必须关联一个 monitor，当这个对象的 monitor 被持有后，将处于锁定的状态，不允许其它的线程进入到 monitor 的代码块。

当线程执行 `monitorenter` 的时候，对应的 monitor 对象会被锁定，然后触发对象的 monitor record 列表来获取锁的相关信息，退出便释放锁，如果 monitor 被持有，获取失败，也会刷新 monitor record 列表来获取锁信息。

### Volatile

被 Volatile 修饰的成员变量具有两成含义

1. 保证了不同线程对这个变量的修改对于其它的线程来讲是立即可见的
2. 禁止指令重排序

```java
//线程1
boolean stop = false;
while(!stop){
    doSomething();
}

//线程2
stop = true;
```

这段代码有可能导致无法中断线程，当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程 2 转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。

用volatile修饰之后

第一：使用volatile关键字会强制将修改的值立即写入主存；

第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；

第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。

那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，
然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。

那么线程1读取到的就是最新的正确的值。

#### Volatile 实现原理

如果对声明了 volatile 变量进行写操作时，JVM 会向处理器发送一条 Lock 前缀的指令，JVM 会对 LOCK 进行特殊处理。

#### Volatile 可见性实现

如果对声明了 volatile 变量进行写操作时，JVM 会向处理器发送一条 Lock 前缀的指令，将这个变量所在缓存行的数据写会到系统内存。 这一步确保了如果有其他线程对声明了 volatile 变量进行修改，则立即更新主内存中数据。

在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过嗅探在总线上传播的数据来检查 自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，
会强制重新从系统内存把数据读到处理器缓存里。 这一步确保了其他线程获得的声明了 volatile 变量都是从主内存中获取最新的。

#### Volatile 有序性实现

Lock 前缀指令实际上相当于一个内存屏障（也成内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面。
即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。

#### i++ 是原子操作吗

不是

i++ 要经历三个过程：

1. 读取 i 值
2. 计算 i 值
3. 写回 i 值

这三个过程都可能被打断

### Monitor

Monitor 是一个同步机制，也是一个对象。

所有的 Java 对象从被创建起就关联一个 Monitor 对象，所以每个对象都有一把锁，叫做内部锁或者 Monitor 锁。

#### Monitor Record

monitor record 是线程私有的

Owner：初始时为NULL表示当前没有任何线程拥有该 monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为 NULL；

EntryQ：关联一个系统互斥锁（semaphore），阻塞所有试图锁住 monitor record 失败的线程。

RcThis：表示 blocked 或 waiting 在该 monitor record 上的所有线程的个数。

Nest：用来实现重入锁的计数。

HashCode：保存从对象头拷贝过来的 HashCode 值（可能还包含 GC age）。

Candidate：用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。

Candidate 只有两种可能的值： 0 表示没有需要唤醒的线程， 1 表示要唤醒一个继任线程来竞争锁。

### 对象头

在对象头当中存放了两部分信息：Mark Word(标记字段)、Klass Pointer(类型指针)。

Mark word 用来存放对象运行时候的数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。

Klass Pointer 用来指向这个对象的 类 元数据信息，可以根据 Klass Pointer 来判断该对象属于哪个类。

#### 对象头大小

如果对象为普通对象，对象头一般占两个机器码，在 32 位虚拟机上，1 个机器码占 4 字节，也就是 32 bit。

如果对象为数组，对象头占三个机器码，因为 JVM 可以通过对象的元数据信息确定对象的大小，但是无法从数据的元数据信息确认数组的大小，所以多余的一块用来记录数组的大小。

对象头信息是对象自身数据之外的信息，所以为了考虑到空间，对象头当中的 Mark Word 一般被设计成为一个非固定的数据结构以便在极小的空间内存放更多的数据。

## 内存模型

### 什么是内存模型

内存模型是针对并发一块来讲的，C 与 C++ 语言在并发上都是使用物理硬件和操作系统的内存模型，就会导致在一个平台上并发没有问题，但是在另外一个平台上就会有线程安全的问题，所以 Java 为了在程序在各种平台下都能达到一致的内存访问效果，定了一种 Java 内存模型来屏蔽掉各种硬件和操作系统的内存访问差异。

Java 内存模型包括两部分：

1. 主内存与工作内存的交互模型；
2. 主内存与工作内存的交互规则；

### 主内存和工作内存的交互模型

Java 内存模型规定了所有的变量都存储在主内存中。每条线程中还有自己的工作内存，线程的工作内存中保存了被该线程所使用到的变量（这些变量是从主内存中拷贝而来）。
线程对变量的所有操作（读取，赋值）都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。

### 主内存与工作内存的交互规则

内存交换原则分作两个小块，1.变量交互规则。2.volatile 的特殊规定。

### 内存模型的实现

#### 指令重排序

在执行程序时，为了提高性能，编译器和处理器会对指令做重排序。但是，JMM确保在不同的编译器和不同的处理器平台之上，通过插入特定类型的Memory Barrier来禁止特定类型的编译器重排序和处理器重排序，为上层提供一致的内存可见性保证。

1. 编译器优化重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序；
2. 指令级并行的重排序：如果不存l在数据依赖性，处理器可以改变语句对应机器指令的执行顺序；
3. 内存系统的重排序：处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行；

#### 数据依赖

如果两个操作访问同一个变量，其中一个为写操作，此时这两个操作之间存在数据依赖性。

编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序，即不会重排序。

#### as-if-serial

不管怎么重排序，单线程下的执行结果不能被改变，编译器、runtime 和处理器都必须遵守 as-if-serial 语义。

#### 内存屏障（Memory Barrier ）

通过内存屏障可以禁止特定类型处理器的重排序，从而让程序按我们预想的流程去执行。内存屏障，又称内存栅栏，是一个CPU指令

编译器和 CPU 能够重排序指令，保证最终相同的结果，尝试优化性能。插入一条 Memory Barrier 会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。

Memory Barrier 所做的另外一件事是强制刷出各种 CPU cache，如一个 Write-Barrier（写入屏障）将刷出所有在 Barrier 之前写入 cache 的数据，因此，任何 CPU 上的线程都能读取到这些数据的最新版本。

如果一个变量是 volatile 修饰的，JMM 会在写入这个字段之后插进一个 Write-Barrier 指令，并在读这个字段之前插入一个 Read-Barrier 指令。

这意味着，如果写入一个 volatile 变量，就可以保证，一个线程写入变量 a 后，任何线程访问该变量都会拿到最新值。

#### happens-before 原则

在内存模型当中中，如果一个操作的执行结果需要对另一个操作可见，那么这两个操作之间必须要存在 happens-before 关系，这个的两个操作既可以在同一个线程，
也可以在不同的两个线程中。

监视器锁规则：对一个锁的解锁操作，happens-before 于随后对这个锁的加锁操作。

传递性规则：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。

### 可见性

可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。

而普通的共享变量不能保证可见性，普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。

通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。

```java
//线程1执行的代码
int i = 0;

i = 10;

//线程2执行的代码
j = i;

```

由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到工作内存中，然后赋值为10，那么在线程1的工作内存当中i的值变为10了，却没有立即写入到主存当中。

此时线程2执行 j = i，它会先去主存读取i的值并加载到线程2的工作内存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.

### 有序性

即程序执行的顺序按照代码的先后顺序执行。

在 CPU 执行的时候，可能会把代码的顺序打乱，然后来提高执行的效率，叫做指令重排序，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。

在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，synchronized和Lock保证每个时刻是有一个线程执行同步代码，
相当于是让线程顺序执行同步代码，就保证了有序性。

### 原子性

即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

在 Java 当中只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作

```Java
int x = 10;
int y = x;
x++;
x = x + 1;
```

咋一看，可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。

语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。

语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。

同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。

所以上面4个语句只有语句1的操作具备原子性。

## 内存区域

### JVM 内存区域划分

根据 《Java 虚拟机规范》的规定, 运行时数据区通常包括这几个部分: 

- 程序计数器（Program Counter Register）
- 本地方法栈（Native Method Stack）
- 方法区（Method Area）
- Java 栈（VM stack）
- Java 堆 （VM heap）

JVM 规范当中虽然规定了程序在执行期间运行时数据区应该包括几部分, 具体实现没有做规定。

### 程序计数器

程序计数器存储的是当前线程所要执行的下一条字节码指令的地址, Java 是多线程的, 所以程序计数器是线程独立的才能保证线程之间不会相互干扰

Jvm 规范当中规定, 如果线程执行的非 Navive 的方法, 则程序计数器当中保存的是需要执行的指令的地址, 如果线程执行的是 navive 方法, 那么程序计数器中的值是 undefined

由于程序计数器当中的存储的数据所占空间的大小不会随程序的改变而改变, 所以程序计数器没有设定 OutOfMemory Exception 异常

### 方法区
